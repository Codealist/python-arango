from __future__ import absolute_import, unicode_literals

from arango import APIWrapper
from arango.cursor import Cursor
from arango.exceptions import (
    AQLQueryExplainError,
    AQLQueryValidateError,
    AQLQueryExecuteError,
    AQLFunctionCreateError,
    AQLFunctionDeleteError,
    AQLFunctionListError,
    AQLCacheClearError,
    AQLCacheConfigureError,
    AQLCachePropertiesError
)
from arango import Request
from arango.utils import HTTP_OK


class AQL(APIWrapper):
    """Wrapper for invoking ArangoDB Query Language (AQL).

    :param requester: ArangoDB API requester object.
    :type requester: arango.requesters.Requester
    """

    def __init__(self, requester):
        super(AQL, self).__init__(requester)
        self._cache = AQLQueryCache(requester)

    def __repr__(self):
        return '<ArangoDB AQL>'

    @property
    def cache(self):
        """Return the query cache object.

        :return: The query cache object.
        :rtype: arango.query.AQLQueryCache
        """
        return self._cache

    def explain(self, query, all_plans=False, max_plans=None, opt_rules=None):
        """Inspect the query and return its metadata.

        :param query: The query to inspect.
        :type query: str | unicode
        :param all_plans: If set to True, all possible execution plans are
            returned. If set to False, only the optimal one is returned.
        :type all_plans: bool
        :param max_plans: The total number of plans generated by the optimizer.
        :type max_plans: int
        :param opt_rules: The list of optimizer rules.
        :type opt_rules: list
        :return: The plan (or plans if **all_plans** is set to True).
        :rtype: list | dict
        :raise arango.exceptions.AQLQueryExplainError: If the explain fails.
        """
        options = {'allPlans': all_plans}
        if max_plans is not None:
            options['maxNumberOfPlans'] = max_plans
        if opt_rules is not None:
            options['optimizer'] = {'rules': opt_rules}

        request = Request(
            method='post',
            endpoint='/_api/explain',
            data={'query': query, 'options': options}
        )

        def response_handler(res):
            if res.status_code not in HTTP_OK:
                raise AQLQueryExplainError(res)

            if 'plan' in res.body:
                return res.body['plan']
            else:
                return res.body['plans']

        return self._execute_request(request, response_handler)

    def validate(self, query):
        """Validate the query.

        :param query: The query to validate.
        :type query: str | unicode
        :return: True if the validation is successful.
        :rtype: bool
        :raise arango.exceptions.AQLQueryValidateError: If validation fails.
        """
        request = Request(
            method='post',
            endpoint='/_api/query',
            data={'query': query}
        )

        def response_handler(res):
            if res.status_code not in HTTP_OK:
                raise AQLQueryValidateError(res)
            res.body.pop('code', None)
            res.body.pop('error', None)
            return res.body

        return self._execute_request(request, response_handler)

    def execute(self,
                query,
                count=False,
                batch_size=None,
                ttl=None,
                bind_vars=None,
                full_count=None,
                max_plans=None,
                optimizer_rules=None,
                cache=None,
                memory_limit=0,
                fail_on_warning=None,
                profile=None,
                max_transaction_size=None,
                max_warning_count=None,
                intermediate_commit_count=None,
                intermediate_commit_size=None,
                satellite_sync_wait=None):
        """Execute the query and return the result cursor.

        :param query: The AQL query to execute.
        :type query: str | unicode
        :param count: If set to True, the document count is included in the
            cursor.
        :type count: bool
        :param batch_size: The number of documents fetched in one round trip.
        :type batch_size: int
        :param ttl: Server side time-to-live for the cursor in seconds.
        :type ttl: int
        :param bind_vars: Bind variables for the query.
        :type bind_vars: dict
        :param full_count: This parameter only applies to queries with LIMIT
            clauses. If set to True, the cursor will include the full count:
            the number of matched documents before the last LIMIT clause is
            executed. Similar to MySQL's SQL_CALC_FOUND_ROWS hint, this can
            be retrieve the number of documents found where only a subset is
            returned. Using this disables a few LIMIT optimizations and may
            lead to more documents being processed and longer query execution.
        :type full_count: bool
        :param max_plans: maximum number of plans the optimizer generates
        :type max_plans: int
        :param optimizer_rules: list of optimizer rules
        :type optimizer_rules: [str | unicode]
        :param cache: If set to True, the query cache is used. The operation
            mode of the cache must be set to "on" or "demand".
        :type cache: bool
        :param memory_limit: The maximum amount of memory (in bytes) the query
            is allowed to use. If the query goes over the limit, it fails with
            error "resource limit exceeded". Value 0 indicates no limit.
        :type memory_limit: int
        :param fail_on_warning: If set to True, the query throws an exception
            instead of producing a warning. This parameter can be used during
            development to catch issues early. If set to False, warnings are
            returned with the query result. There is a server configuration
            option "--query.fail-on-warning" for setting the default value for
            this behaviour so it does not need to be set on a per-query level.
        :type fail_on_warning: bool
        :param profile: If set to True, additional profiling information is
            returned in the cursor (unless the query cache is used).
        :type profile: bool
        :param max_transaction_size: Transaction size limit in bytes. Applies
            only to RocksDB storage engine.
        :type max_transaction_size: int
        :param max_warning_count: Maximum number of warnings queries return.
        :type max_warning_count: int
        :param intermediate_commit_count: Maximum number of operations after
            which an intermediate commit is performed automatically. Applies
            only to RocksDB storage engine.
        :type intermediate_commit_count: int
        :param intermediate_commit_size: Maximum total size of operations after
            which an intermediate commit is performed automatically. Applies
            only to RocksDB storage engine.
        :type intermediate_commit_size: int
        :param satellite_sync_wait: Number of seconds in which the server must
            synchronize the satellite collections involved in the query. When
            the threshold is reached the query is stopped. This parameter is
            for enterprise version of ArangoDB only.
        :type satellite_sync_wait: int | float
        :return: document cursor
        :rtype: arango.cursor.Cursor
        :raise arango.exceptions.AQLQueryExecuteError: If the query cannot be
            executed
        :raise arango.exceptions.CursorCloseError: If the cursor cannot be
            closed properly
        """
        data = {'query': query, 'count': count}
        if batch_size is not None:
            data['batchSize'] = batch_size
        if ttl is not None:
            data['ttl'] = ttl
        if bind_vars is not None:
            data['bindVars'] = bind_vars
        if cache is not None:
            data['cache'] = cache
        if memory_limit is not None:
            data['memoryLimit'] = memory_limit

        options = {}
        if full_count is not None:
            options['fullCount'] = full_count
        if max_plans is not None:
            options['maxNumberOfPlans'] = max_plans
        if optimizer_rules is not None:
            options['optimizer'] = {'rules': optimizer_rules}
        if fail_on_warning is not None:
            options['failOnWarning'] = fail_on_warning
        if profile is not None:
            options['profile'] = profile
        if max_transaction_size is not None:
            options['maxTransactionSize'] = max_transaction_size
        if max_warning_count is not None:
            options['maxWarningCount'] = max_warning_count
        if intermediate_commit_count is not None:
            options['intermediateCommitCount'] = intermediate_commit_count
        if intermediate_commit_size is not None:
            options['intermediateCommitSize'] = intermediate_commit_size
        if satellite_sync_wait is not None:
            options['satelliteSyncWait'] = satellite_sync_wait
        if options:
            data['options'] = options

        request = Request(
            method='post',
            endpoint='/_api/cursor',
            data=data
        )

        def response_handler(res):
            if res.status_code not in HTTP_OK:
                raise AQLQueryExecuteError(res)
            return Cursor(self._requester, res.body)

        return self._execute_request(request, response_handler)

    def functions(self):
        """List the AQL functions defined in this database.

        :return: Mapping of AQL function names to their javascript code.
        :rtype: dict
        :raise arango.exceptions.AQLFunctionListError: If the retrieval fails.
        """
        request = Request(method='get', endpoint='/_api/aqlfunction')

        def response_handler(res):
            if res.status_code not in HTTP_OK:
                raise AQLFunctionListError(res)
            body = res.body or {}
            return {func['name']: func['code'] for func in map(dict, body)}

        return self._execute_request(request, response_handler)

    def create_function(self, name, code):
        """Create a new AQL function.

        :param name: The name of the new AQL function.
        :type name: str | unicode
        :param code: The function definition in Javascript.
        :type code: str | unicode
        :return: True if the AQL function was created successfully.
        :rtype: bool
        :raise arango.exceptions.AQLFunctionCreateError: If the create fails.
        """
        request = Request(
            method='post',
            endpoint='/_api/aqlfunction',
            data={'name': name, 'code': code}
        )

        def response_handler(res):
            if res.status_code not in (200, 201):
                raise AQLFunctionCreateError(res)
            return not res.body['error']

        return self._execute_request(request, response_handler)

    def delete_function(self, name, group=None, ignore_missing=False):
        """Delete an AQL function.

        :param name: The name of the AQL function.
        :type name: str | unicode
        :param group: If set to True, value of parameter **name** is treated
            as a namespace prefix, and all functions in the namespace are
            deleted. If set to False, the value of **name** must be a fully
            qualified function name including any namespaces.
        :type group: bool
        :param ignore_missing: Do not raise an exception on missing function.
        :type ignore_missing: bool
        :return: True if the AQL function was deleted successfully.
        :rtype: bool
        :raise arango.exceptions.AQLFunctionDeleteError: If the delete fails.
        """
        params = {}
        if group is not None:
            params['group'] = group

        request = Request(
            method='delete',
            endpoint='/_api/aqlfunction/{}'.format(name),
            params=params
        )

        def response_handler(res):
            if res.status_code not in HTTP_OK:
                if not (res.status_code == 404 and ignore_missing):
                    raise AQLFunctionDeleteError(res)
            return not res.body['error']

        return self._execute_request(request, response_handler)


class AQLQueryCache(APIWrapper):
    """ArangoDB query cache."""

    def __repr__(self):
        return '<ArangoDB AQL query cache>'

    def properties(self):
        """Return the query cache properties.

        :return: The cache properties
        :rtype: dict
        :raise arango.exceptions.AQLCachePropertiesError: If the cache
            properties cannot be retrieved
        """
        request = Request(
            method='get',
            endpoint='/_api/query-cache/properties'
        )

        def response_handler(res):
            if res.status_code not in HTTP_OK:
                raise AQLCachePropertiesError(res)
            return {'mode': res.body['mode'], 'limit': res.body['maxResults']}

        return self._execute_request(request, response_handler)

    def configure(self, mode=None, limit=None):
        """Configure the query cache properties.

        :param mode: The operation mode ("off", "on" or "demand").
        :type mode: str | unicode
        :param limit: The maximum number of results to be stored.
        :type limit: int
        :return: The result of the operation.
        :rtype: dict
        :raise arango.exceptions.AQLCacheConfigureError: If the config fails.
        """
        data = {}
        if mode is not None:
            data['mode'] = mode
        if limit is not None:
            data['maxResults'] = limit

        request = Request(
            method='put',
            endpoint='/_api/query-cache/properties',
            data=data
        )

        def response_handler(res):
            if res.status_code not in HTTP_OK:
                raise AQLCacheConfigureError(res)
            return {'mode': res.body['mode'], 'limit': res.body['maxResults']}

        return self._execute_request(request, response_handler)

    def clear(self):
        """Clear the query cache.

        :return: The result of the operation.
        :rtype: dict
        :raise arango.exceptions.AQLCacheClearError: If the clear fails.
        """
        request = Request(
            method='delete',
            endpoint='/_api/query-cache'
        )

        def response_handler(res):
            if res.status_code not in HTTP_OK:
                raise AQLCacheClearError(res)
            return not res.body['error']

        return self._execute_request(request, response_handler)
